
struct MinDist <: Metric end
const MINDIST = MinDist  # spell it the way the papers do, if desired

"""
    mindist(word1, word2)

Evaluate the MINDIST between two words.
"""
mindist(word1, word2) = evaluate(MinDist(), word1, word2)

# helper
function distance_sanity_check(word1, word2)
	msg = "for distances to be computable between two words, "
	word1.approximator[] == word2.approximator[] || 
		error("$msg, they must have been generated by the same model")
	word1.n == word2.n || 
		error("$msg, their original sequences must have the same lengths")
	return true
end

function Distances.evaluate(
		dist::MinDist, 
		word1::Word{<:ContinuousApproximator}, 
		word2::Word{<:ContinuousApproximator}
	)
	distance_sanity_check(word1, word2)
	return euclidean(values(word1), values(word2)) * sqrt(compression_rate(word1))
end

function Distances.evaluate(
		dist::MinDist, word1::Word{SA, T, 1}, word2::Word{SA, T, 1}
	) where {SA <: SymbolicApproximator, T}
	distance_sanity_check(word1, word2)
	keys1 = keys(word1)
	keys2 = keys(word2)
	approximator = word1.approximator[]
	total = 0.0
	for (i, j) in zip(keys1, keys2)
		d = symbol_distance(approximator, i, j)
		total += d^2
	end
	return sqrt(total) * sqrt(compression_rate(word1))
end

function Distances.evaluate(
		dist::MinDist, word1::Word{SA, T, W}, word2::Word{SA, T, W}
	) where {SA <: SymbolicApproximator, T, W}
	distance_sanity_check(word1, word2)
	keys1 = reinterpret(Int, keys(word1))
	keys2 = reinterpret(Int, keys(word2))
	approximator = word1.approximator[]
	total = 0.0
	for (i, j) in zip(keys1, keys2)
		d = symbol_distance(approximator, i, j)
		total += d^2
	end
	return sqrt(total) * sqrt(compression_rate(word1))
end

function symbol_distance(approximator::Union{SAX, ESAX}, i::Int, j::Int)
	β = breakpoints(approximator)
	if abs(i - j) <= 1
       return 0.0
   end
	if i > j
		i, j = j, i
	end
	lo = 0
	hi = length(β)
	i = clamp(i, lo:hi)
	j = clamp(j, lo:hi)
   return β[j] - β[i+1]
end


